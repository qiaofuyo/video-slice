<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>视频剪辑指令生成器</title>
  <!-- Tailwind CSS（用于快速布局） -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- mpegts.js（替代 flv.js，用于播放 .flv/.ts/.mp4 等） -->
  <script src="https://cdn.jsdelivr.net/npm/mpegts.js@1.8.0/dist/mpegts.min.js"></script>

  <style>
    body { font-family: 'Inter', sans-serif; }
    #file-input { display: none; }

    /* 浮动视频窗口 */
    #video-float-window {
      position: fixed;
      z-index: 50;
      pointer-events: none; /* 默认穿透（只有控件可交互） */
      transition: opacity .2s;
      resize: both;
      overflow: hidden;
    }
    /* 手柄与控件需要可交互 */
    #drag-handle { position:absolute; top:0; left:0; width:100%; height:90%; cursor:move; z-index:52; pointer-events:auto; background:transparent; }
    #resize-handle { position:absolute; bottom:0; right:0; width:20px; height:20px; cursor:se-resize; z-index:54; pointer-events:auto; background:rgba(0,0,0,.4); border-radius:4px 0 4px 0; }
    .control-btn { position:absolute; top:5px; z-index:53; pointer-events:auto; text-shadow:0 0 5px rgba(0,0,0,.5); }
    #close-float-btn { right:5px; }
    #restore-float-btn { right:45px; }

    /* 拖拽高亮 */
    #drop-zone.drag-over { border-color:#3b82f6; background:#e0f2fe; }
    /* 确保 video 控件可交互 */
    #video-player { pointer-events: auto; display:block; width:100%; height:100%; }
    
    /* 新增：当前播放文件高亮样式 */
    #file-list .playing {
      background-color: #dbeafe; /* Tailwind blue-100 */
      border-color: #60a5fa; /* Tailwind blue-400 */
    }
  </style>
</head>

<body class="bg-gray-100">
  <div class="flex flex-col h-screen p-8 space-y-8 overflow-y-auto">
    <div class="bg-white rounded-xl shadow-2xl p-8 w-full">
      <h1 class="text-3xl font-bold text-center mb-2 text-gray-800">视频剪辑指令生成器</h1>
      <p class="text-center text-gray-500 mb-6">选择视频文件 → 标记时间点 → 生成 FFmpeg 指令</p>

      <!-- 文件选择 / 拖拽区 -->
      <div id="drop-zone" class="mb-6 border-2 border-dashed border-gray-300 rounded-lg p-6 text-center transition-colors duration-200">
        <p class="text-gray-500 mb-4">将视频拖拽到此处，或</p>
        <label for="file-input" class="cursor-pointer bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg">选择视频文件</label>
        <input id="file-input" type="file" accept="video/*" multiple>
        <div id="file-list" class="mt-4 space-y-2"></div>
      </div>

      <!-- 播放与标记区域（默认隐藏，选中文件后显示） -->
      <div id="video-player-section" class="mb-6 hidden">
        <h2 class="text-xl font-bold text-gray-800 mb-4">视频播放与标记</h2>

        <!-- 快捷键与秒/分钟设定 -->
        <div class="mt-4 text-center text-gray-600">
          <p class="text-sm font-semibold">
            空格：播放/暂停 | 上：标记开始 | 下：标记结束 | ←/→：后退/前进（秒） | Ctrl+←/→：后退/前进（分钟）
          </p>
          <div class="flex flex-wrap items-center justify-center gap-4 mt-4">
            <div class="flex items-center gap-2"><label>快退秒:</label><input id="fast-backward-seconds" type="number" value="5" min="1" class="w-16 p-1 border rounded-md text-sm text-center"></div>
            <div class="flex items-center gap-2"><label>快进秒:</label><input id="fast-forward-seconds" type="number" value="15" min="1" class="w-16 p-1 border rounded-md text-sm text-center"></div>
            <div class="flex items-center gap-2"><label>长快退(分):</label><input id="long-fast-backward-minutes" type="number" value="2" min="1" class="w-16 p-1 border rounded-md text-sm text-center"></div>
            <div class="flex items-center gap-2"><label>长快进(分):</label><input id="long-fast-forward-minutes" type="number" value="2" min="1" class="w-16 p-1 border rounded-md text-sm text-center"></div>
          </div>
          <!-- 新增：可点击的快进快退按钮 -->
          <div class="flex flex-wrap items-center justify-center gap-4 mt-2">
            <button id="rewind-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 py-1 px-3 rounded-lg text-sm">快退秒</button>
            <button id="forward-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 py-1 px-3 rounded-lg text-sm">快进秒</button>
            <button id="long-rewind-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 py-1 px-3 rounded-lg text-sm">长快退(分)</button>
            <button id="long-forward-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 py-1 px-3 rounded-lg text-sm">长快进(分)</button>
          </div>
        </div>

        <!-- 标记按钮 -->
        <div class="flex items-center justify-center gap-4 mt-4">
          <button id="mark-start-btn" class="bg-green-500 hover:bg-green-600 text-white py-2 px-4 rounded-lg">标记开始</button>
          <button id="mark-end-btn" class="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg">标记结束</button>
          <button id="add-clip-btn" class="bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg">添加片段</button>
        </div>

        <!-- 手动输入时间（格式 hhmmss 或 hh:mm:ss 的数字） -->
        <div class="mt-4 flex justify-center gap-2 items-center">
          <label class="font-semibold">手动输入:</label>
          <input id="manual-start-time" type="text" placeholder="开始时间 (hhmmss)" class="p-2 border rounded-md text-sm text-center">
          <span>-</span>
          <input id="manual-end-time" type="text" placeholder="结束时间 (hhmmss)" class="p-2 border rounded-md text-sm text-center">
        </div>
      </div>

      <!-- 剪辑片段列表 -->
      <div id="clips-list-section" class="mb-6 hidden">
        <h2 class="text-xl font-bold text-gray-800 mb-4">已添加的剪辑片段</h2>

        <!-- 主播名输入 -->
        <div class="flex items-center gap-3 mb-4">
          <label for="hostNameInput" class="text-gray-700 font-medium">主播名：</label>
          <input id="hostNameInput"
                type="text"
                placeholder="填写主播名（例如：荔枝甜心）"
                aria-label="主播名"
                class="p-2 border rounded-md text-sm w-64"
          />
        </div>

        <div id="added-clips-list" class="space-y-2"></div>
      </div>

      <!-- 操作按钮与路径输入 -->
      <div class="mt-8 flex justify-center gap-4">
        <button id="generate-btn" class="bg-green-600 hover:bg-green-700 text-white py-3 px-6 rounded-lg">生成 FFmpeg 指令</button>
        <button id="copy-btn" class="bg-gray-800 hover:bg-gray-900 text-white py-3 px-6 rounded-lg">复制指令</button>
      </div>

      <div class="mt-4 flex items-center gap-2">
        <label class="text-gray-800 font-bold">视频文件目录:</label>
        <input id="video-source-path-input" type="text" value="E:\下载" placeholder="例如：C:\Users\YourName\Videos" class="flex-1 p-2 border rounded-md text-sm">
      </div>
      <div class="mt-4 flex items-center gap-2">
        <label class="text-gray-800 font-bold">输出目录:</label>
        <input id="output-path-input" type="text" value="E:\下载\截取" placeholder="例如：C:\Users\YourName\Videos" class="flex-1 p-2 border rounded-md text-sm">
      </div>

      <!-- 指令输出 -->
      <div class="mt-8">
        <label class="block text-gray-700 font-bold mb-2">生成的指令：</label>
        <textarea id="output-commands" readonly rows="10" class="w-full p-4 border rounded-lg text-sm bg-gray-50 text-gray-700"></textarea>
        <p class="text-gray-500 text-sm mt-2">提示：将指令粘贴到终端（CMD/PowerShell）中执行。</p>
      </div>

      <!-- 简单提示弹窗（固定位置，初始隐藏通过透明度） -->
      <div id="message-box" class="fixed bottom-4 right-4 bg-gray-800 text-white py-2 px-4 rounded-lg shadow-lg opacity-0 transition-opacity duration-300 z-50">提示</div>
    </div>
  </div>

  <!-- 视频悬浮窗口（浮动播放器） -->
  <div id="video-float-window" class="hidden rounded-xl overflow-hidden shadow-2xl">
    <div class="relative w-full h-full max-w-full max-h-screen">
      <video id="video-player" controls preload="metadata"></video>
      <div id="drag-handle"></div>
      <div id="resize-handle"></div>
      <button id="close-float-btn" class="control-btn text-white text-3xl bg-gray-800 bg-opacity-50 hover:bg-opacity-75 rounded-full w-8 h-8 flex items-center justify-center">&times;</button>
      <button id="restore-float-btn" class="control-btn text-white text-2xl bg-gray-800 bg-opacity-50 hover:bg-opacity-75 rounded-full w-8 h-8 flex items-center justify-center">&#x21BA;</button>
    </div>
  </div>

  <script>
    /******************************************************************
     * 全局状态与 DOM 引用（必要变量，去掉未使用项）
     ******************************************************************/
    let clips = [];                  // 存储添加的剪辑片段对象
    let selectedFiles = [];          // 存储已选择的 File 对象列表
    let currentFile = null;          // 当前正在播放的文件对象
    let currentObjectURL = null;     // 当前为 video 创建的 object URL（便于 revoke）
    let mpegtsPlayer = null;         // mpegts.js 的实例（若使用 .flv/.ts/.mp4）
    let initialVideoWidth = 0;       // 用于恢复默认大小
    let initialVideoHeight = 0;
    let currentClipEndTime = null;   // 播放片段时的结束时间（秒）
    let tempStartTime = null;        // 临时保存标记的开始时间（秒）
    let tempEndTime = null;          // 临时保存标记的结束时间（秒）

    // DOM 引用
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');
    const fileListDiv = document.getElementById('file-list');
    const videoPlayerSection = document.getElementById('video-player-section');
    const videoFloatWindow = document.getElementById('video-float-window');
    const dragHandle = document.getElementById('drag-handle');
    const resizeHandle = document.getElementById('resize-handle');
    const closeFloatBtn = document.getElementById('close-float-btn');
    const restoreFloatBtn = document.getElementById('restore-float-btn');
    const videoPlayer = document.getElementById('video-player');

    const markStartBtn = document.getElementById('mark-start-btn');
    const markEndBtn = document.getElementById('mark-end-btn');
    const addClipBtn = document.getElementById('add-clip-btn');
    const clipsListSection = document.getElementById('clips-list-section');
    const addedClipsList = document.getElementById('added-clips-list');
    const generateBtn = document.getElementById('generate-btn');
    const copyBtn = document.getElementById('copy-btn');
    const outputCommands = document.getElementById('output-commands');
    const messageBox = document.getElementById('message-box');

    const fastForwardSecondsInput = document.getElementById('fast-forward-seconds');
    const fastBackwardSecondsInput = document.getElementById('fast-backward-seconds');
    const longFastForwardMinutesInput = document.getElementById('long-fast-forward-minutes');
    const longFastBackwardMinutesInput = document.getElementById('long-fast-backward-minutes');
    
    // 新增：快进快退按钮引用
    const rewindBtn = document.getElementById('rewind-btn');
    const forwardBtn = document.getElementById('forward-btn');
    const longRewindBtn = document.getElementById('long-rewind-btn');
    const longForwardBtn = document.getElementById('long-forward-btn');

    const videoSourcePathInput = document.getElementById('video-source-path-input');
    const outputPathInput = document.getElementById('output-path-input');

    const manualStartTimeInput = document.getElementById('manual-start-time');
    const manualEndTimeInput = document.getElementById('manual-end-time');

    /******************************************************************
     * 时间格式化与解析辅助函数
     ******************************************************************/
    // 秒 -> "HH:MM:SS"
    function formatTime(seconds) {
      const date = new Date(null);
      date.setSeconds(Math.floor(seconds));
      return date.toISOString().substr(11, 8);
    }

    // 支持 "hhmmss"（或带非数字字符）的解析，返回秒或 null
    function parseTime(timeString) {
      const s = (timeString || '').replace(/\D/g, '');
      if (!s) return null;
      // 最多取 6 位（hhmmss）
      const padded = s.padStart(6, '0');
      const h = parseInt(padded.slice(-6, -4), 10);
      const m = parseInt(padded.slice(-4, -2), 10);
      const sec = parseInt(padded.slice(-2), 10);
      return h * 3600 + m * 60 + sec;
    }

    // 2) 新增：添加片段命名所需辅助函数
    function basenameNoExt(name){ return (name || '').replace(/\.[^/.]+$/, ''); }
    function pad(n){ return n<10? '0'+n : ''+n; }
    function formatDateYYYYMMDD(ms){ var d = (typeof ms === 'number') ? new Date(ms) : new Date(ms); return ''+d.getFullYear()+pad(d.getMonth()+1)+pad(d.getDate()); }

    /******************************************************************
     * 辅助：安全创建并管理 Object URL
     ******************************************************************/
    function setVideoObjectURL(blobOrFile) {
      if (currentObjectURL) {
        URL.revokeObjectURL(currentObjectURL);
        currentObjectURL = null;
      }
      const url = URL.createObjectURL(blobOrFile);
      currentObjectURL = url;
      return url;
    }

    /******************************************************************
     * 公共：清理 player（抽出公共逻辑）
     ******************************************************************/
    function cleanupPlayer() {
      // 销毁 mpegtsPlayer（如果存在）
      if (mpegtsPlayer) {
        try { mpegtsPlayer.destroy(); } catch (e) { /* ignore */ }
        mpegtsPlayer = null;
      }
      // 撤销 object URL
      if (currentObjectURL) {
        try { URL.revokeObjectURL(currentObjectURL); } catch (e) {}
        currentObjectURL = null;
      }
      // 清空 video src 并重置状态
      try { videoPlayer.removeAttribute('src'); videoPlayer.load(); } catch (e) {}
      currentFile = null;
      currentClipEndTime = null;
      renderFileList(); // 更新：移除高亮
    }

    /******************************************************************
     * 公共：加载 file（抽成函数，统一处理 mpegts.js / 原生）
     * callback 在媒体可播放时被调用（用于开始播放或设置大小）
     ******************************************************************/
    function loadFile(file, callbackOnReady) {
      if (!file) return;
      // 先统一清理旧资源
      cleanupPlayer();
      currentFile = file;
      renderFileList(); // 更新：设置高亮
      const ext = file.name.split('.').pop().toLowerCase();

      // 显示浮窗（由回调处理播放）
      videoFloatWindow.classList.remove('hidden');

      // 如果浏览器支持 mpegts.js，并且文件是 flv/ts/m2ts（或你也想用 mpegts.js 播放 mp4），则优先用 mpegts
      const canUseMpegts = window.mpegts && mpegts.getFeatureList; // 库存在的弱判定
      if (canUseMpegts && ['flv', 'ts', 'm2ts'].includes(ext)) {
        const url = setVideoObjectURL(file);
        // map ext -> mpegts type
        let type = 'mpegts';
        if (ext === 'flv') type = 'flv';
        if (ext === 'ts' || ext === 'm2ts') type = (ext === 'm2ts' ? 'm2ts' : 'mpegts');

        try {
          mpegtsPlayer = mpegts.createPlayer({
            type,
            isLive: false,
            filesize: file.size,
            url
          }, {
            enableWorker: true,
            enableStashBuffer: true,
            stashInitialSize: 384 * 1024 * 10,  // 指示 IO 存储缓冲区的初始大小
            lazyLoad: true,  // 如果有足够的数据可供播放，则中止 http 连接
            lazyLoadMaxDuration: 10 * 60,  // 懒加载
            lazyLoadRecoverDuration: 3 * 60,  // 恢复边界
            autoCleanupSourceBuffer: true,  // 自动清理 SourceBuffer
            autoCleanupMinBackwardDuration: 2 * 60,  // 保留 2 分钟用于回退
            autoCleanupMaxBackwardDuration: 5 * 60,  // 当向后缓冲区持续时间超过此值时，自动清理 SourceBuffer（删除更早的）
          });
          mpegtsPlayer.attachMediaElement(videoPlayer);
          mpegtsPlayer.load();
          // 等待视频元数据可用
          videoPlayer.addEventListener('loadedmetadata', function onceMeta() {
            videoPlayer.removeEventListener('loadedmetadata', onceMeta);
            if (typeof callbackOnReady === 'function') callbackOnReady();
          }, { once: true });
        } catch (e) {
          console.warn('mpegts.createPlayer 失败，回退至原生播放：', e);
          const url2 = setVideoObjectURL(file);
          videoPlayer.src = url2;
          videoPlayer.addEventListener('loadedmetadata', function onceMeta2() {
            videoPlayer.removeEventListener('loadedmetadata', onceMeta2);
            if (typeof callbackOnReady === 'function') callbackOnReady();
          }, { once: true });
        }
      } else if (canUseMpegts && ext === 'mp4') {
        // 对 mp4：你可以让 mpegts 处理（type:'mp4'），但对本地文件通常使用原生 <video> 更可靠
        // 这里优先使用原生行为（更稳定且无需 transmux）
        const url = setVideoObjectURL(file);
        videoPlayer.src = url;
        videoPlayer.addEventListener('loadedmetadata', function onceMeta() {
          videoPlayer.removeEventListener('loadedmetadata', onceMeta);
          if (typeof callbackOnReady === 'function') callbackOnReady();
        }, { once: true });
      } else {
        // 普通文件使用原生 loadedmetadata（兜底）
        const url = setVideoObjectURL(file);
        videoPlayer.src = url;
        videoPlayer.addEventListener('loadedmetadata', function onceMeta() {
          videoPlayer.removeEventListener('loadedmetadata', onceMeta);
          if (typeof callbackOnReady === 'function') callbackOnReady();
        }, { once: true });
      }
    }

    function renderFileList() {
      fileListDiv.innerHTML = '';
      if (selectedFiles.length === 0) {
        videoPlayerSection.classList.add('hidden');
      } else {
        videoPlayerSection.classList.remove('hidden');
      }

      selectedFiles.forEach((file, idx) => {
        const div = document.createElement('div');
        div.className = 'flex items-center justify-between p-2 bg-gray-100 rounded-lg border border-gray-200';
        
        // 更新：检查是否为当前播放文件，如果是则添加高亮 class
        if (currentFile && file.name === currentFile.name && file.size === currentFile.size) {
          div.classList.add('playing');
        }

        div.innerHTML = `
          <span class="font-semibold text-gray-800 break-words">${file.name}</span>
          <div class="flex gap-2">
            <button class="play-file-btn bg-blue-500 text-white py-1 px-3 rounded-lg text-sm" data-index="${idx}">播放</button>
            <button class="delete-file-btn bg-red-400 text-white py-1 px-3 rounded-lg text-sm" data-index="${idx}">删除</button>
          </div>
        `;
        fileListDiv.appendChild(div);
      });
    }

    /******************************************************************
     * 处理文件输入（拖拽 / 选择）
     ******************************************************************/
    function handleFiles(list) {
      if (!list || list.length === 0) return;
      const filesArr = Array.from(list);
      const newFiles = filesArr.filter(f => !selectedFiles.some(sf => sf.name === f.name && sf.size === f.size));
      if (newFiles.length > 0) {
        selectedFiles.push(...newFiles);
        renderFileList();
        showMessage(`已添加 ${newFiles.length} 个文件。`);
      } else {
        showMessage('未添加新文件。');
      }
    }

    fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('drag-over'); });
    dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
    dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('drag-over'); handleFiles(e.dataTransfer.files); });

    /******************************************************************
     * 播放文件（使用 loadFile 封装）
     ******************************************************************/
    function playSelectedFile(file) {
      if (!file) return;
      loadFile(file, () => {
        setInitialVideoSizeAndCenter(videoPlayer.videoWidth || initialVideoWidth, videoPlayer.videoHeight || initialVideoHeight);
        showMessage(`正在播放: ${currentFile.name}`);
        videoPlayer.play().catch(()=>{});
      });
    }

    // 停止并隐藏播放器（使用 cleanupPlayer）
    function stopAndHidePlayer() {
      videoFloatWindow.classList.add('hidden');
      try { videoPlayer.pause(); } catch (e) {}
      try { videoPlayer.currentTime = 0; } catch(e){}
      cleanupPlayer();
    }

    /******************************************************************
     * 设置浮动窗口的初始大小并居中
     ******************************************************************/
    function setInitialVideoSizeAndCenter(videoWidth, videoHeight) {
      if (!videoWidth || !videoHeight) return;
      initialVideoWidth = videoWidth;
      initialVideoHeight = videoHeight;

      const aspect = videoWidth / videoHeight;
      const maxW = window.innerWidth * 0.8;
      const maxH = window.innerHeight * 0.8;
      let w = videoWidth, h = videoHeight;
      if (w > maxW) { w = maxW; h = w / aspect; }
      if (h > maxH) { h = maxH; w = h * aspect; }

      videoFloatWindow.style.width = `${w}px`;
      videoFloatWindow.style.height = `${h}px`;
      centerVideoWindow();
    }

    function centerVideoWindow() {
      if (videoFloatWindow.classList.contains('hidden')) return;
      const ww = window.innerWidth, wh = window.innerHeight;
      const ew = videoFloatWindow.offsetWidth, eh = videoFloatWindow.offsetHeight;
      videoFloatWindow.style.left = `${(ww - ew) / 2}px`;
      videoFloatWindow.style.top = `${(wh - eh) / 2}px`;
    }
    window.addEventListener('resize', centerVideoWindow);

    /******************************************************************
     * 标记 / 添加片段
     ******************************************************************/
    // 标记开始时间（取当前播放时间）
    markStartBtn.addEventListener('click', () => {
      if (!currentFile && !videoPlayer.src) { showMessage('请先选择并播放视频'); return; }
      tempStartTime = videoPlayer.currentTime;
      manualStartTimeInput.value = formatTime(tempStartTime).replace(/:/g, '');
      showMessage('已标记开始时间');
    });

    // 标记结束时间
    markEndBtn.addEventListener('click', () => {
      if (!currentFile && !videoPlayer.src) { showMessage('请先选择并播放视频'); return; }
      tempEndTime = videoPlayer.currentTime;
      manualEndTimeInput.value = formatTime(tempEndTime).replace(/:/g, '');
      showMessage('已标记结束时间');
    });

    // 2) 在“添加片段”的逻辑处：改为规则命名并保存元数据
    addClipBtn.addEventListener('click', () => {
      if (!currentFile) { showMessage('请先选择视频文件'); return; }
      const startSec = parseTime(manualStartTimeInput.value);
      const endSec = parseTime(manualEndTimeInput.value);
      if (startSec === null || endSec === null) { showMessage('请先标记或输入开始/结束时间'); return; }
      if (startSec >= endSec) { showMessage('结束时间必须晚于开始时间'); return; }

      // helper
      // (已在全局定义：basenameNoExt / pad / formatDateYYYYMMDD)

      // derive host (fallback from filename)
      var host='unknown';
      try { var base = basenameNoExt(currentFile.name); host = base.split('_')[0] || base; host = host.replace(/[\/\\:\*\?"<>\|]/g,'_'); } catch(e){ host='unknown'; }

      // prefer UI input
      var hostInputEl = document.getElementById('hostNameInput');
      var hostUsed = host;
      if (hostInputEl && hostInputEl.value && hostInputEl.value.trim() !== '') {
        hostUsed = hostInputEl.value.trim().replace(/[\/\\:\*\?"<>\|]/g,'_');
      }

      // file date from metadata
      var fileDate = '00000000';
      try {
        if (currentFile && currentFile.lastModified) fileDate = formatDateYYYYMMDD(currentFile.lastModified);
        else fileDate = formatDateYYYYMMDD(Date.now());
      } catch(e) { fileDate = formatDateYYYYMMDD(Date.now()); }

      // index: count existing clips from same file
      var sameCount = 0;
      if (Array.isArray(clips)) {
        for (var i=0;i<clips.length;i++){
          var c = clips[i];
          var src = c.fileName || c.inputFileName || c.sourceFileName || '';
          if (!src && c.file && c.file.name) src = c.file.name;
          if (src && currentFile && src === currentFile.name) sameCount++;
        }
      }
      var index = sameCount + 1;
      var outName = hostUsed + '_' + fileDate + '_' + index + '.mp4';
      window.__lastGeneratedHost = hostUsed;
      window.__lastGeneratedFileDate = fileDate;

      // 3) push 时保存更多字段
      clips.push({
        fileName: currentFile.name,
        startTime: formatTime(startSec),
        endTime: formatTime(endSec),
        outputFileName: outName,
        host: (window.__lastGeneratedHost !== undefined) ? window.__lastGeneratedHost : hostUsed,
        fileDate: (window.__lastGeneratedFileDate !== undefined) ? window.__lastGeneratedFileDate : fileDate,
        originalFileSize: currentFile.size,
        originalFileLastModified: currentFile.lastModified || null
      });

      // 清空临时标记输入
      tempStartTime = tempEndTime = null;
      manualStartTimeInput.value = '';
      manualEndTimeInput.value = '';

      renderClipsList();
      showMessage(`已添加片段：${currentFile.name} (${formatTime(startSec)} - ${formatTime(endSec)})`);
    });

    /******************************************************************
     * 渲染剪辑列表（只渲染 DOM，事件使用委托绑定在外部）
     ******************************************************************/
    function renderClipsList() {
      addedClipsList.innerHTML = '';
      if (clips.length === 0) {
        clipsListSection.classList.add('hidden');
        return;
      }
      clipsListSection.classList.remove('hidden');

      clips.forEach((clip, i) => {
        const parts = clip.outputFileName.split('.');
        const nameWithoutExt = parts.slice(0, -1).join('.');
        const ext = parts[parts.length - 1];
        const item = document.createElement('div');
        item.className = 'flex items-center justify-between p-3 bg-gray-50 rounded-lg border border-gray-200';
        item.innerHTML = `
          <div class="flex flex-col md:flex-row md:items-center md:space-x-4">
            <span class="text-sm font-bold">${clip.fileName}</span>
            <span class="text-sm text-gray-600">${clip.startTime} - ${clip.endTime}</span>
            <div class="flex items-center gap-2">
              <label class="text-xs">输出名称:</label>
              <input class="output-name" data-index="${i}" value="${nameWithoutExt}" style="width:220px;padding:4px;border:1px solid #ddd;border-radius:4px;">
              <span>.</span>
              <input class="output-ext" data-index="${i}" value="${ext}" style="width:60px;padding:4px;border:1px solid #ddd;border-radius:4px;">
            </div>
          </div>
          <div class="flex gap-2">
            <button class="play-clip-btn bg-purple-500 text-white py-1 px-2 rounded text-xs" data-index="${i}">播放片段</button>
            <button class="delete-clip-btn bg-red-400 text-white py-1 px-2 rounded text-xs" data-index="${i}">删除</button>
          </div>
        `;
        addedClipsList.appendChild(item);
      });
    }

    // 4) 新增自动重编号函数
    function renumberIndicesForSource(sourceFileName) {
      if (!sourceFileName) return;
      var count = 0;
      for (var i = 0; i < clips.length; i++) {
        var clip = clips[i];
        if (clip.fileName === sourceFileName) {
          count++;
          var h = clip.host || (document.getElementById('hostNameInput') ? document.getElementById('hostNameInput').value.trim().replace(/[\/\\:\*\?"<>\|]/g,'_') : (clip.fileName ? clip.fileName.split('_')[0] : 'unknown'));
          var fd = clip.fileDate || (clip.originalFileLastModified ? (function(d){ var D=new Date(d); function pad(n){return n<10?'0'+n:''+n;} return ''+D.getFullYear()+pad(D.getMonth()+1)+pad(D.getDate()); })(clip.originalFileLastModified) : (clip.fileDate || '00000000'));
          clip.outputFileName = h + '_' + fd + '_' + count + '.mp4';
        }
      }
    }

    /******************************************************************
     * 使用事件委托替代多次 querySelectorAll(...).forEach(...) 绑定
     * - fileListDiv: 处理播放/删除文件
     * - addedClipsList: 处理播放/删除片段与输出名/扩展名输入
     ******************************************************************/
    fileListDiv.addEventListener('click', (e) => {
      const playBtn = e.target.closest('.play-file-btn');
      const delBtn = e.target.closest('.delete-file-btn');
      if (playBtn) {
        const idx = parseInt(playBtn.dataset.index, 10);
        const file = selectedFiles[idx];
        if (file) playSelectedFile(file);
        return;
      }
      if (delBtn) {
        const idx = parseInt(delBtn.dataset.index, 10);
        const f = selectedFiles[idx];
        if (!f) return;
        selectedFiles.splice(idx, 1);
        // 如果被删除的是当前播放文件，则停止播放并清理
        if (currentFile && currentFile.name === f.name && currentObjectURL) {
          stopAndHidePlayer();
        }
        showMessage(`已删除文件: ${f.name}（相关剪辑片段保留）`);
        renderFileList();
        renderClipsList();
      }
    });

    // 委托处理 clips 列表内的按钮与输入
    addedClipsList.addEventListener('click', (e) => {
      const playBtn = e.target.closest('.play-clip-btn');
      const delBtn = e.target.closest('.delete-clip-btn');
      if (playBtn) {
        const idx = parseInt(playBtn.dataset.index, 10);
        const clip = clips[idx];
        const originalFile = selectedFiles.find(f => f.name === clip.fileName && f.size === clip.originalFileSize);
        if (!originalFile) { showMessage(`错误：找不到原始文件 ${clip.fileName}`); return; }

        // 如果已加载且与当前文件一致，直接跳转播放；否则使用 loadFile
        if (currentFile && currentFile.name === originalFile.name && currentFile.size === originalFile.size && currentObjectURL && videoPlayer.src === currentObjectURL) {
          playClipRange(clip);
        } else {
          loadFile(originalFile, () => playClipRange(clip));
        }
        return;
      }
      if (delBtn) {
        const idx = parseInt(delBtn.dataset.index, 10);
        // 5) 删除时先 splice 并保存 removed，然后调用 renumber 再 render
        var removed = clips.splice(idx, 1)[0];
        if (removed && removed.fileName) renumberIndicesForSource(removed.fileName);
        renderClipsList();
        showMessage('已删除片段');
      }
    });

    // 处理 output name/ext 的 input 事件（委托）
    addedClipsList.addEventListener('input', (e) => {
      const nameInp = e.target.closest('.output-name');
      const extInp = e.target.closest('.output-ext');
      if (nameInp) {
        const idx = parseInt(nameInp.dataset.index, 10);
        if (!isNaN(idx) && clips[idx]) {
          const ext = clips[idx].outputFileName.split('.').pop();
          clips[idx].outputFileName = `${nameInp.value}.${ext}`;
        }
      }
      if (extInp) {
        const idx = parseInt(extInp.dataset.index, 10);
        if (!isNaN(idx) && clips[idx]) {
          const base = clips[idx].outputFileName.replace(/\.[^/.]+$/, "");
          clips[idx].outputFileName = `${base}.${extInp.value}`;
        }
      }
    });

    /******************************************************************
     * 播放 clip 的时间段（clip.startTime/clip.endTime 为 "HH:MM:SS"）
     ******************************************************************/
    function playClipRange(clip) {
      currentClipEndTime = parseTime(clip.endTime);
      videoPlayer.currentTime = parseTime(clip.startTime);
      videoPlayer.play().catch(()=>{});
      showMessage(`正在播放片段: ${clip.fileName} (${clip.startTime} - ${clip.endTime})`);
    }

    // 监听播放进度，自动在片段结束时停止
    videoPlayer.addEventListener('timeupdate', () => {
      if (currentClipEndTime !== null && videoPlayer.currentTime >= currentClipEndTime) {
        videoPlayer.pause();
        videoPlayer.currentTime = currentClipEndTime;
        currentClipEndTime = null;
        showMessage('片段播放结束');
      }
    });

    /******************************************************************
     * 生成 FFmpeg 指令并复制
     ******************************************************************/
    generateBtn.addEventListener('click', () => {
      if (clips.length === 0) { outputCommands.value = '没有任何剪辑片段。'; showMessage('请先添加片段'); return; }
      const srcDir = videoSourcePathInput.value.trim();
      const outDir = outputPathInput.value.trim();
      if (!srcDir) { outputCommands.value = '请先输入视频文件所在目录。'; showMessage('请输入视频文件目录'); return; }
      if (!outDir) { outputCommands.value = '请先输入输出目录。'; showMessage('请输入输出目录'); return; }

      // 规范反斜杠（Windows 格式）
      const inDir = srcDir.replace(/\//g, '\\');
      const oDir = outDir.replace(/\//g, '\\');

      let cmds = '';
      clips.forEach(clip => {
        const inputPath = `${inDir}\\${clip.fileName}`;
        const outputPath = `${oDir}\\${clip.outputFileName}`;
        // -ss -to 在输入前/后的使用会影响精确性；此处采用简单可复制的形式
        cmds += `ffmpeg -loglevel quiet -ss "${clip.startTime}" -to "${clip.endTime}" -i "${inputPath}" -c copy "${outputPath}"\n`;
      });
      outputCommands.value = cmds.trim();
    });

    copyBtn.addEventListener('click', () => {
      if (!outputCommands.value) { showMessage('没有可复制的指令'); return; }
      outputCommands.select();
      try {
        if (document.execCommand('copy')) showMessage('已复制到剪贴板');
        else showMessage('复制失败，请手动复制');
      } catch (e) { showMessage('复制失败，请手动复制'); }
      window.getSelection().removeAllRanges();
    });

    /******************************************************************
     * 新增：为快进/快退按钮添加事件监听
     ******************************************************************/
    function seekVideo(seconds) {
      if (!videoPlayer.src || isNaN(videoPlayer.duration)) {
        showMessage('请先播放一个视频');
        return;
      }
      const newTime = videoPlayer.currentTime + seconds;
      videoPlayer.currentTime = Math.max(0, Math.min(newTime, videoPlayer.duration));
      const direction = seconds > 0 ? '前进' : '后退';
      const unit = Math.abs(seconds) >= 60 ? '分钟' : '秒';
      const amount = Math.abs(seconds) >= 60 ? Math.abs(seconds) / 60 : Math.abs(seconds);
      showMessage(`${direction} ${amount} ${unit}`);
    }

    forwardBtn.addEventListener('click', () => {
      const seconds = parseFloat(fastForwardSecondsInput.value) || 15;
      seekVideo(seconds);
    });

    rewindBtn.addEventListener('click', () => {
      const seconds = parseFloat(fastBackwardSecondsInput.value) || 5;
      seekVideo(-seconds);
    });

    longForwardBtn.addEventListener('click', () => {
      const minutes = parseFloat(longFastForwardMinutesInput.value) || 2;
      seekVideo(minutes * 60);
    });

    longRewindBtn.addEventListener('click', () => {
      const minutes = parseFloat(longFastBackwardMinutesInput.value) || 2;
      seekVideo(-minutes * 60);
    });

    /******************************************************************
     * 全局键盘（合并：支持 Escape、空格、方向键与标记快捷键）
     ******************************************************************/
    document.addEventListener('keydown', (e) => {
      // 当焦点在输入框时，不触发快捷键，以免影响正常输入
      if (['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
        return;
      }

      // Escape 始终关闭浮窗（如果可见）
      if (e.key === 'Escape' && !videoFloatWindow.classList.contains('hidden')) {
        stopAndHidePlayer(); return;
      }
      // 以下操作需要有视频 src 才有效
      if (!videoPlayer.src) return;

      if (e.key === ' ') {
        e.preventDefault();
        if (videoPlayer.paused) { videoPlayer.play(); showMessage('播放'); }
        else { videoPlayer.pause(); showMessage('暂停'); }
        return;
      }

      const ffSec = parseFloat(fastForwardSecondsInput.value) || 15;
      const fbSec = parseFloat(fastBackwardSecondsInput.value) || 5;
      const longFfMin = parseFloat(longFastForwardMinutesInput.value) || 2;
      const longFbMin = parseFloat(longFastBackwardMinutesInput.value) || 2;

      if (e.ctrlKey) {
        if (e.key === 'ArrowRight') { e.preventDefault(); seekVideo(longFfMin * 60); }
        if (e.key === 'ArrowLeft')  { e.preventDefault(); seekVideo(-longFbMin * 60); }
      } else {
        if (e.key === 'ArrowRight') { e.preventDefault(); seekVideo(ffSec); }
        if (e.key === 'ArrowLeft')  { e.preventDefault(); seekVideo(-fbSec); }
      }

      if (e.key === 'ArrowUp')    { e.preventDefault(); markStartBtn.click(); }
      if (e.key === 'ArrowDown')  { e.preventDefault(); markEndBtn.click(); }
    });

    /******************************************************************
     * 浮窗拖拽与缩放（简单实现）
     ******************************************************************/
    dragHandle.addEventListener('mousedown', (e) => {
      e.preventDefault();
      if (e.button !== 0) return;
      const startX = e.clientX, startY = e.clientY;
      const rect = videoFloatWindow.getBoundingClientRect();
      const left0 = rect.left, top0 = rect.top;
      document.body.style.userSelect = 'none';
      function onMove(ev) {
        videoFloatWindow.style.left = `${left0 + (ev.clientX - startX)}px`;
        videoFloatWindow.style.top = `${top0 + (ev.clientY - startY)}px`;
      }
      function onUp() { document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); document.body.style.userSelect = ''; }
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });

    resizeHandle.addEventListener('mousedown', (e) => {
      e.preventDefault();
      if (e.button !== 0) return;
      const startX = e.clientX;
      const rect = videoFloatWindow.getBoundingClientRect();
      const initW = rect.width, initH = rect.height;
      const aspect = initW / initH;
      document.body.style.userSelect = 'none';
      function onMove(ev) {
        const dx = ev.clientX - startX;
        let newW = initW + dx;
        let newH = newW / aspect;
        const minSize = 200;
        if (newW < minSize) { newW = minSize; newH = newW / aspect; }
        const left = parseFloat(videoFloatWindow.style.left) || 0;
        const top = parseFloat(videoFloatWindow.style.top) || 0;
        if (left + newW > window.innerWidth) newW = window.innerWidth - left;
        if (top + newH > window.innerHeight) newH = window.innerHeight - top;
        videoFloatWindow.style.width = `${newW}px`;
        videoFloatWindow.style.height = `${newH}px`;
      }
      function onUp() { document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); document.body.style.userSelect = ''; }
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });

    // 关闭/恢复按钮
    closeFloatBtn.addEventListener('click', stopAndHidePlayer);
    restoreFloatBtn.addEventListener('click', () => {
      if (initialVideoWidth > 0 && initialVideoHeight > 0) {
        setInitialVideoSizeAndCenter(initialVideoWidth, initialVideoHeight);
        showMessage('已恢复默认大小和位置');
      } else showMessage('未加载视频，无法恢复');
    });

    /******************************************************************
     * 简单消息显示：显示一段时间后自动隐藏
     ******************************************************************/
    function showMessage(text) {
      messageBox.textContent = text;
      messageBox.classList.remove('opacity-0');
      messageBox.classList.add('opacity-100');
      clearTimeout(showMessage._timer);
      showMessage._timer = setTimeout(() => {
        messageBox.classList.remove('opacity-100');
        messageBox.classList.add('opacity-0');
      }, 2500);
    }

    // 页面加载时的初始渲染
    renderFileList();
    renderClipsList();
  </script>
</body>
</html>
